--- jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp	2025-10-22 19:58:20.786481182 +0200
@@ -2206,7 +2206,7 @@
   if (operand_valid_for_add_sub_immediate((int)imm)) {
     (this->*insn1)(Rd, Rn, imm);
   } else {
-    if (uabs(imm) < (1 << 24)) {
+    if (g_uabs(imm) < (1 << 24)) {
        (this->*insn1)(Rd, Rn, imm & -(1 << 12));
        (this->*insn1)(Rd, Rd, imm & ((1 << 12)-1));
     } else {
--- jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/assembler_aarch64.cpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/assembler_aarch64.cpp	2025-10-22 19:58:20.796480882 +0200
@@ -1702,7 +1702,7 @@
 }
 
 bool Assembler::operand_valid_for_add_sub_immediate(int64_t imm) {
-  uint64_t uimm = (uint64_t)uabs((jlong)imm);
+  uint64_t uimm = (uint64_t)g_uabs((jlong)imm);
   if (uimm < (1 << 12))
     return true;
   if (uimm < (1 << 24)
--- jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/assembler_aarch64.hpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/assembler_aarch64.hpp	2025-10-22 19:58:20.809813817 +0200
@@ -854,7 +854,7 @@
   static const uint64_t branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 
   static bool reachable_from_branch_at(address branch, address target) {
-    return uabs(target - branch) < branch_range;
+    return g_uabs(target - branch) < branch_range;
   }
 
   // Unconditional branch (immediate)
--- jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp	2025-10-22 19:58:20.819813518 +0200
@@ -1009,7 +1009,7 @@
 
   void copy_memory_small(Register s, Register d, Register count, Register tmp, int step) {
     bool is_backwards = step < 0;
-    size_t granularity = uabs(step);
+    size_t granularity = g_uabs(step);
     int direction = is_backwards ? -1 : 1;
     int unit = wordSize * direction;
 
@@ -1065,7 +1065,7 @@
                    Register count, Register tmp, int step) {
     copy_direction direction = step < 0 ? copy_backwards : copy_forwards;
     bool is_backwards = step < 0;
-    unsigned int granularity = uabs(step);
+    unsigned int granularity = g_uabs(step);
     const Register t0 = r3, t1 = r4;
 
     // <= 80 (or 96 for SIMD) bytes do inline. Direction doesn't matter because we always
--- jdk11u-jdk-11.0.29-ga/src/hotspot/share/utilities/globalDefinitions.hpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/share/utilities/globalDefinitions.hpp	2025-10-22 19:58:20.829813219 +0200
@@ -1166,7 +1166,7 @@
 
 // abs methods which cannot overflow and so are well-defined across
 // the entire domain of integer types.
-static inline unsigned int uabs(unsigned int n) {
+static inline unsigned int g_uabs(unsigned int n) {
   union {
     unsigned int result;
     int value;
@@ -1175,7 +1175,7 @@
   if (value < 0) result = 0-result;
   return result;
 }
-static inline julong uabs(julong n) {
+static inline julong g_uabs(julong n) {
   union {
     julong result;
     jlong value;
@@ -1184,8 +1184,8 @@
   if (value < 0) result = 0-result;
   return result;
 }
-static inline julong uabs(jlong n) { return uabs((julong)n); }
-static inline unsigned int uabs(int n) { return uabs((unsigned int)n); }
+static inline julong g_uabs(jlong n) { return g_uabs((julong)n); }
+static inline unsigned int g_uabs(int n) { return g_uabs((unsigned int)n); }
 
 // "to" should be greater than "from."
 inline intx byte_size(void* from, void* to) {
--- jdk11u-jdk-11.0.29-ga/src/hotspot/share/opto/mulnode.cpp.orig	2025-10-13 23:11:58.000000000 +0200
+++ jdk11u-jdk-11.0.29-ga/src/hotspot/share/opto/mulnode.cpp	2025-10-22 19:58:20.839812919 +0200
@@ -194,7 +194,7 @@
   // Check for negative constant; if so negate the final result
   bool sign_flip = false;
 
-  unsigned int abs_con = uabs(con);
+  unsigned int abs_con = g_uabs(con);
   if (abs_con != (unsigned int)con) {
     sign_flip = true;
   }
@@ -290,7 +290,7 @@
 
   // Check for negative constant; if so negate the final result
   bool sign_flip = false;
-  julong abs_con = uabs(con);
+  julong abs_con = g_uabs(con);
   if (abs_con != (julong)con) {
     sign_flip = true;
   }
